# Тип Wrapper

Тип **Wrapper** является классом-оберткой вокруг любого пользовательского типа.

```cpp
template < typename _Value, typename _Tool >
class Wrapper;
```

Экземпляр типа **Wrapper** полностью эмулирует сам экземпляр типа **_Value** с добавлением любых особенностей, реализуемых посредством инструментария **_Tool**.

К таким особенностям относятся, например,
- выбор размещения экземпляра **_Value**: по месту владельца/в куче.
- ленивые вычисления: copy-on-write и т.п.
- потокобезопасность
- и др.

Собственно, экземпляр типа **Wrapper** агрегирует (любым способом) экземпляр типа **_Value**, владеет им, управляет временем его жизни, обеспечивает применение дополнительных свойств и предоставляет доступ к экземпляру типа **_Value**.



# Суперпозиция Wrapper

Возможна суперпозиция при применении обертки **Wrapper**. Порядок декларации оберток в суперпозиции определяет порядок применения свойств к внутреннему экземпляру значения **_Value**.

Например, в записи

```cpp
Wrapper< Wrapper< Value, Implicit::SharedTool >, ThreadSafe::RecursiveMutexTool > first;
Wrapper< Wrapper< Value, ThreadSafe::RecursiveMutexTool >, Implicit::SharedTool > second;
```

экземпляр значения ```first``` является потокобезопасным неявно распределнным значением типа **Value**, а экземпляр значения ```second``` - наявно распределенным потокобезопасным значением типа **Value**. И это не одно и тоже! По своей сути сам экземпляр значения ```first``` не является неявно распределенным, а ```second``` - потокобезопасным. Этими особенностями обладают вложенные в них значения.

# Совместимость типов и вложенность Wrapper

Для проверки, является ли тип разновидностью **Wrapper**, определены

```cpp
template < typename _Test >
struct IsWrapper; // ::std::true_type or ::std::false_type
template < typename _Test >
inline constexpr bool isWrapper ();
```
которое равно ```true```, если тип **_Test** является **Wrapper**, и ```false``` в остальных случаях.

Между конкретными типами определено отношение совместимости, для проверки условия, когда первый тип **_Test** может быть представлен, как другой **_Other**.

```cpp
template < _Test, _Other >
struct IsThisCompatibleWithOther; // ::std::true_type or ::std::false_type
template < _Test, _Other >
inline constexpr bool isThisCompatibleWithOther ();
```

Для произвольных типов значение этого отношение равно ```true```, если тип **_Other** является базовым или идентичным типу **_Test** с учетом const/volatile модификаторов. Для типов **Wrapper** значение отношения совместимости равно ```true```, если для них задан одинаковый инструментарий **_Tool** и типы внутренних значений **_Value** являются совместимыми. В остальных случаях значение отношения совместимости равно ```false```.

Для конкретных типов **Wrapper** также определено отношение вложенности, для проверки условия, когда внутренний тип **_Other** (любой степени вложенности) совместим с типом **_Test**.

```cpp
template < _Test, _Other >
struct IsThisCompatibleWithPartOfOther; // ::std::true_type or ::std::false_type
template < _Test, _Other >
inline constexpr bool IsThisCompatibleWithPartOfOther ();
```

Для произвольных типов значение этого отношения равно ```false```. Для типов **Wrapper** значение отношения равно ```true```, если тип **_Test** совместим с любой вложенной частью типа **_Other**.

Совместимость и вложенность типов **Wrapper** является важным аспектом в реализации их взаимодействия в бинарных операторах. Если типы **Wrapper** совместимы, то для них может быть реализована специализация бинарных операторов. Если типы **Wrapper** имеют отношение вложености, то они "раскрываются" до совместимых типов, между которыми реализуется бинарный оператор.

# Доступ к значениям

Перед тем, как для **Wrapper** предоставить доступ к внутреннему экземпляру значения **_Value**, к последнему необходимо применить особенности, реализуемые инструментарием **_Tool**. Применение этих особенностей обеспечивают типы из раздела **Access** - **WrapperGuard**, **ValueGuard** и **ValuePointer**.

Если у вложенного типа **_Value** не переопределен унарный оператор получения адреса '&', то результатом действия этого оператора будет специальный указатель **ValuePointer**, который на всем протяжении своего времени жизни обеспечивает применение всех особенностей для экземпляра значения **_Value**, на который он указывает.
